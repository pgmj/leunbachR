---
title: "Introduction to Leunbach test equating"
author: "Magnus Johansson, PhD"
output: html_document
---

This document provides an overview of how to do direct and indirect equating using the `leunbachR` package for R.

## Setup

First, we load the package and a dataset.

```{r}
library(leunbachR)
set.seed(1234) # for reproducibility of bootstrap results
d3a <- read.delim("data3a.csv", sep = ";")
```

Looking at our data, we can see that it has two variables containing sum scores from the two tests that we want to equate.

```{r}
head(d3a)
```

## Direct equating

First, we estimate the model.

```{r}
fit <- leunbach_ipf(d3a, verbose = FALSE)
```

For most functions in this package, you can use `print()`, `summary()`, and `plot()` to investigate the results. All functions have documentation that you can access using for instance `?leunbach_ipf` in the R console.

```{r}
summary(fit)
```

```{r}
print(fit)
```

```{r}
calculate_statistics(fit)$std_residuals
```


### Analyze orbits

```{r}
orb <- analyze_orbits(fit)
summary(orb)
print(orb)
```

```{r}
plot(orb)
plot(orb, type = "significant")
```

Specific total scores can also be analyzed.

```{r}
get_orbit(orb, total_score = 5)
```

### Equating

```{r}
leunbach_equate(fit, verbose = TRUE, direction = "1to2")
```

### Bootstrap

If you have installed the package `mirai` and have a computer with multiple CPU cores, you can significantly reduce the time needed for bootstrap. Note that not all cores are equal. For instance, on a modern Mac, you should only use the "performance cores", not the "efficiency cores".

```{r}
boot <- leunbach_bootstrap(fit, n_cores = 12, verbose = TRUE)

```

```{r}
print(boot)
```




## Indirect equating

For this, we read a dataset with three tests.

```{r}
d1 <- read.delim("data1.csv", sep = ";")
head(d1)
```

We will estimate two models before the indirecy equating procedure. Test A with Test B; and Test B with Test C. The code below uses base R methods to select the columns in the dataframe, first 1 and 2, second 2 and 3.

```{r}
fit_ab <- leunbach_ipf(d1[,c(1,2)])
fit_bc <- leunbach_ipf(d1[,c(2,3)])
```

You can of course use the objects `fit_ab` and `fit_bc` to analyze orbits too, but we'll skip that step here.

```{r}
indirect1 <- leunbach_indirect_equate(fit_ab, fit_bc,
                                     direction_ab = "1to2",
                                     direction_bc = "1to2")
print(indirect1)
```

### Bootstrap

```{r}
boot_indirect1 <- leunbach_indirect_bootstrap(fit_ab, fit_bc,
                                             direction_ab = "1to2",
                                             direction_bc = "1to2",
                                             nsim = 1000,
                                             verbose = TRUE, n_cores = 12)
```

```{r}
print(boot_indirect1)
summary(boot_indirect1)
```

```{r}
plot(boot_indirect1, type = "equating")
```


```{r}
plot(boot_indirect1, type = "see")
```

