% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/equate_indirect.R
\name{leunbach_indirect_equate}
\alias{leunbach_indirect_equate}
\title{Indirect Equating via an Anchor Test}
\usage{
leunbach_indirect_equate(
  fit_ab,
  fit_bc,
  direction_ab = c("1to2", "2to1"),
  direction_bc = c("1to2", "2to1"),
  method = c("optimize", "newton"),
  verbose = FALSE
)
}
\arguments{
\item{fit_ab}{A leunbach_ipf object for the A-B equating (Tests A and B)}

\item{fit_bc}{A leunbach_ipf object for the B-C equating (Tests B and C)}

\item{direction_ab}{Direction for A-B equating:  "1to2" or "2to1"}

\item{direction_bc}{Direction for B-C equating: "1to2" or "2to1"}

\item{method}{Optimization method: "optimize" (default) or "newton"}

\item{verbose}{Print detailed output}
}
\value{
A list of class "leunbach_indirect" containing:
\itemize{
\item equating_table: Data frame with source scores, expected equated scores, and rounded scores
\item eq_ab: Direct equating object for A → B
\item eq_bc: Direct equating object for B → C
\item fit_ab: Original leunbach_ipf object for A-B
\item fit_bc:  Original leunbach_ipf object for B-C
}
}
\description{
Performs indirect equating from Test A to Test C via an anchor Test B.
This chains two direct equatings:  A → B and B → C.
}
\details{
Indirect equating works by chaining two direct equatings:
\enumerate{
\item For a score x on Test A, find the expected score on Test B (typically non-integer)
\item Find expected Test C scores for the integer B scores below and above
\item Interpolate to get the expected Test C score for the non-integer B score
\item Round to get the equated integer score
}
}
\examples{
# Fit models for A-B and B-C
fit_ab <- leunbach_ipf(data_ab)
fit_bc <- leunbach_ipf(data_bc)

# Indirect equating:  Test1 of fit_ab → Test2 of fit_ab → Test2 of fit_bc
indirect <- leunbach_indirect_equate(fit_ab, fit_bc, 
                                      direction_ab = "1to2", 
                                      direction_bc = "1to2")
print(indirect)

}
