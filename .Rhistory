labs(title = "Test equating on sum score scale",
color = "Equating model", shape = "Equating model", linetype = "Equating model",
y = "Predicted Y value", x = "X value")
eq_table %>%
dplyr::select(c(identity,leunbach_theta,IRT_thetaequivalent)) %>%
pivot_longer(!identity) %>%
filter(identity %in% c(1:9)) %>%
ggplot(aes(x = identity, y = value, color = name, shape = name)) +
geom_point(size = 3) +
geom_line() +
scale_x_continuous(breaks = c(0:10), minor_breaks = NULL) +
scale_y_continuous(breaks = c(-2:2)) +
scale_color_viridis_d() +
theme_bw() +
labs(title = "Test equating on theta scale",
color = "Equating model", shape = "Equating model",
y = "Predicted Y value", x = "X value", caption = "Note: Min and max scores are excluded, since these need to be imputed for both methods.") +
theme(plot.caption = element_text(face = "italic", hjust = 0))
glm_a <- glm(count ~ splines::bs(total, df = 3),
family = "poisson", data = rx, x = TRUE)
glm_b <- glm(count ~ splines::bs(total, df = 3),
family = "poisson", data = ry, x = TRUE)
eg_eq <- kequate(
design = "EG",
r = glm_a, s = glm_b,
x = c(0:10), y = c(0:10)
)
data.frame(
predicted = c(eg_eq@equating$eqYx, leq$expected),
Model = c(rep("Kernel equating",11),rep("Leunbach",11)),
sumscore = c(0:10,0:10)
) %>%
filter(identity %in% c(1:9)) %>%
ggplot(aes(x = identity, y = value, color = name, shape = name)) +
geom_point(size = 3) +
geom_line() +
scale_x_continuous(breaks = c(0:10), minor_breaks = NULL) +
scale_y_continuous(breaks = c(-2:2)) +
scale_color_viridis_d() +
theme_bw() +
labs(title = "Test equating on theta scale",
color = "Equating model", shape = "Equating model",
y = "Predicted Y value", x = "X value", caption = "Note: Min and max scores are excluded, since these need to be imputed for both methods.") +
theme(plot.caption = element_text(face = "italic", hjust = 0))
data.frame(
predicted = c(eg_eq@equating$eqYx, leq$expected),
Model = c(rep("Kernel equating",11),rep("Leunbach",11)),
sumscore = c(0:10,0:10)
)
data.frame(
predicted = c(eg_eq@equating$eqYx, leq$expected),
Model = c(rep("Kernel equating",11),rep("Leunbach",11)),
sumscore = c(0:10,0:10)
) %>%
ggplot(aes(x = sumscore, y = predicted, color = Model, shape = Model)) +
geom_point(size = 3) +
geom_line() +
scale_x_continuous(breaks = c(0:10), minor_breaks = NULL) +
scale_y_continuous(breaks = c(-2:2)) +
scale_color_viridis_d() +
theme_bw() +
labs(title = "Test equating on theta scale",
color = "Equating model", shape = "Equating model",
y = "Predicted Y value", x = "X value", caption = "Note: Min and max scores are excluded, since these need to be imputed for both methods.") +
theme(plot.caption = element_text(face = "italic", hjust = 0))
data.frame(
predicted = c(eg_eq@equating$eqYx, leq$expected),
Model = c(rep("Kernel equating",11),rep("Leunbach",11)),
sumscore = c(0:10,0:10)
) %>%
ggplot(aes(x = sumscore, y = predicted, color = Model, shape = Model)) +
geom_point(size = 3) +
geom_line() +
scale_x_continuous(breaks = c(0:10), minor_breaks = NULL) +
#scale_y_continuous(breaks = c(-2:2)) +
scale_color_viridis_d() +
theme_bw() +
labs(title = "Test equating on theta scale",
color = "Equating model", shape = "Equating model",
y = "Predicted Y value", x = "X value", caption = "Note: Min and max scores are excluded, since these need to be imputed for both methods.") +
theme(plot.caption = element_text(face = "italic", hjust = 0))
data.frame(
predicted = c(eg_eq@equating$eqYx, leq$expected),
Model = c(rep("Kernel equating",11),rep("Leunbach",11)),
sumscore = c(0:10,0:10)
) %>%
ggplot(aes(x = sumscore, y = predicted, color = Model, shape = Model)) +
geom_point(size = 3) +
geom_line() +
scale_x_continuous(breaks = c(0:10), minor_breaks = NULL) +
#scale_y_continuous(breaks = c(-2:2)) +
scale_color_viridis_d() +
theme_bw() +
labs(title = "Test equating expected scores",
color = "Equating model", shape = "Equating model",
y = "Predicted Y value", x = "X value") +
theme(plot.caption = element_text(face = "italic", hjust = 0))
lboot2 <- leunbach_bootstrap(lfit, n_cores = 4, nsim = 100, see_type = "expected")
data.frame(score = c(0:10,0:10),
see = c(lboot2[["see_1to2"]],eg_eq@equating$SEEYx),
model = c(rep("Leunbach",11),rep("Kernel (glm)",11))
) %>% ggplot(aes(x=score,y=see, color = model)) +
geom_point(size = 3) +
geom_line() +
theme_bw() +
scale_color_viridis_d(option = "G", end = 0.8) +
labs(title = "Standard error of equating (SEE)",
x = "Sum score", y = "SEE", color = "Equating method")
data.frame(score = c(0:10,0:10),
see = c(lboot2[["see_1to2"]],eg_eq@equating$SEEYx),
model = c(rep("Leunbach",11),rep("Kernel (glm)",11))
) %>% ggplot(aes(x=score,y=see, color = model)) +
geom_point(size = 3) +
geom_line() +
theme_bw() +
scale_x_continuous(breaks = c(0:10), minor_breaks = NULL) +
scale_color_viridis_d(option = "G", end = 0.8) +
labs(title = "Standard error of equating (SEE)",
x = "Sum score", y = "SEE", color = "Equating method")
devtools::document()
devtools::document()
d1 <- read.delim("data/data1.csv", sep = ";")
head(d1)
fit_ab <- leunbach_ipf(d1[,c(1,2)])
fit_bc <- leunbach_ipf(d1[,c(2,3)])
indirect1 <- leunbach_indirect_equate(fit_ab, fit_bc,
direction_ab = "1to2",
direction_bc = "1to2")
print(indirect1)
id1table <- indirect1[["equating_table"]]
id1table
#' Print method for leunbach_indirect objects
#' @export
print.leunbach_indirect <- function(x, ...) {
cat("Leunbach Indirect Equating\n")
cat("==========================\n\n")
cat(sprintf("Path: %s -> %s -> %s\n", x$source_name, x$anchor_name, x$target_name))
cat(sprintf("Method: %s\n\n", x$method))
cat(sprintf("Source (%s) range:  %d to %d\n", x$source_name, x$source_min, x$source_max))
cat(sprintf("Anchor (%s) range: %d to %d\n", x$anchor_name, x$anchor_min, x$anchor_max))
cat(sprintf("Target (%s) range: %d to %d\n\n", x$target_name, x$target_min, x$target_max))
tab <- x$equating_table
# Filter to valid range
valid_idx <- tab$source >= x$source_min & tab$source <= x$source_max
tab <- tab[valid_idx, ]
# Format for display
display_tab <- data.frame(
Score = tab$source,
#Log_Theta = ifelse(is.na(tab$theta) | tab$theta <= 0,
"      NA",
sprintf("%8.4f", log(tab$theta))),
#' Print method for leunbach_indirect objects
#' @export
print.leunbach_indirect <- function(x, ...) {
cat("Leunbach Indirect Equating\n")
cat("==========================\n\n")
cat(sprintf("Path: %s -> %s -> %s\n", x$source_name, x$anchor_name, x$target_name))
cat(sprintf("Method: %s\n\n", x$method))
cat(sprintf("Source (%s) range:  %d to %d\n", x$source_name, x$source_min, x$source_max))
cat(sprintf("Anchor (%s) range: %d to %d\n", x$anchor_name, x$anchor_min, x$anchor_max))
cat(sprintf("Target (%s) range: %d to %d\n\n", x$target_name, x$target_min, x$target_max))
tab <- x$equating_table
# Filter to valid range
valid_idx <- tab$source >= x$source_min & tab$source <= x$source_max
tab <- tab[valid_idx, ]
# Format for display
display_tab <- data.frame(
Score = tab$source,
#Log_Theta = ifelse(is.na(tab$theta) | tab$theta <= 0,
#                   "      NA",
#                   sprintf("%8.4f", log(tab$theta))),
Expected = sprintf("%6.2f", tab$expected),
Rounded = tab$rounded
)
colnames(display_tab) <- c(#x$source_name, "Theta",
paste0("Expected_", x$target_name),
paste0("Rounded_", x$target_name))
print(display_tab, row.names = FALSE)
invisible(x)
}
print(indirect1)
indirect1
#' Print method for leunbach_indirect objects
#' @export
print.leunbach_indirect <- function(x, ...) {
cat("Leunbach Indirect Equating\n")
cat("==========================\n\n")
cat(sprintf("Path: %s -> %s -> %s\n", x$source_name, x$anchor_name, x$target_name))
cat(sprintf("Method: %s\n\n", x$method))
cat(sprintf("Source (%s) range:  %d to %d\n", x$source_name, x$source_min, x$source_max))
cat(sprintf("Anchor (%s) range: %d to %d\n", x$anchor_name, x$anchor_min, x$anchor_max))
cat(sprintf("Target (%s) range: %d to %d\n\n", x$target_name, x$target_min, x$target_max))
tab <- x$equating_table
# Filter to valid range
valid_idx <- tab$source >= x$source_min & tab$source <= x$source_max
tab <- tab[valid_idx, ]
# Format for display
display_tab <- data.frame(
Score = tab$source,
#Log_Theta = ifelse(is.na(tab$theta) | tab$theta <= 0,
#                   "      NA",
#                   sprintf("%8.4f", log(tab$theta))),
Expected = sprintf("%6.2f", tab$expected),
Rounded = tab$rounded
)
colnames(display_tab) <- c(paste0("Score_",x$source_name),
#x$source_name, "Theta",
paste0("Expected_", x$target_name),
paste0("Rounded_", x$target_name))
print(display_tab, row.names = FALSE)
invisible(x)
}
print(indirect1)
boot_indirect1 <- leunbach_indirect_bootstrap(fit_ab, fit_bc,
direction_ab = "1to2",
direction_bc = "1to2",
nsim = 100,
verbose = TRUE, n_cores = 4)
print(boot_indirect1)
#' Print SEE table for indirect equating
#' @keywords internal
print_indirect_see_table <- function(x) {
conf_pct <- round(x$conf_level * 100)
cat(sprintf("Indirect Equating: %s -> %s (with %d%% CI)\n",
x$indirect_eq$source_name, x$indirect_eq$target_name, conf_pct))
cat("=======================================================================================\n\n")
valid <- x$source_scores >= x$source_min & x$source_scores <= x$source_max
# Get theta values from indirect equating table
theta_values <- x$indirect_eq$equating_table$theta
cat("                                                                  Frequency of bootstrap errors\n")
cat(sprintf("Score      Rounded  Expected    %d%% CI          SEE      -2    -1     0    +1    +2   Failed%%\n", conf_pct))
cat("--------------------------------------------------------------------------------------------------------\n")
for (i in which(valid)) {
if (is.na(x$observed_expected[i])) next
# theta_val <- theta_values[i]
# if (is.na(theta_val) || theta_val <= 0) {
#   log_theta_str <- "       NA"
# } else {
#   log_theta_str <- sprintf("%9.5f", log(theta_val))
# }
ci_str <- sprintf("[%5.2f, %5.2f]", x$ci_lower[i], x$ci_upper[i])
cat(sprintf("%5d  %s  %7d    %5.2f   %15s  %5.2f   %5.1f %5.1f %5.1f %5.1f %5.1f   %5.1f%%\n",
x$source_scores[i], log_theta_str, x$observed_rounded[i], x$observed_expected[i],
ci_str, x$see[i],
x$error_freq[i, 1], x$error_freq[i, 2], x$error_freq[i, 3],
x$error_freq[i, 4], x$error_freq[i, 5],
x$prop_failed[i]))
}
cat("--------------------------------------------------------------------------------------------------------\n")
cat(sprintf("Average SEE: %.2f\n", x$avg_see))
}
print(boot_indirect1)
#' Print SEE table for indirect equating
#' @keywords internal
print_indirect_see_table <- function(x) {
conf_pct <- round(x$conf_level * 100)
cat(sprintf("Indirect Equating: %s -> %s (with %d%% CI)\n",
x$indirect_eq$source_name, x$indirect_eq$target_name, conf_pct))
cat("=======================================================================================\n\n")
valid <- x$source_scores >= x$source_min & x$source_scores <= x$source_max
# Get theta values from indirect equating table
theta_values <- x$indirect_eq$equating_table$theta
cat("                                                                  Frequency of bootstrap errors\n")
cat(sprintf("Score      Rounded  Expected    %d%% CI          SEE      -2    -1     0    +1    +2   Failed%%\n", conf_pct))
cat("--------------------------------------------------------------------------------------------------------\n")
for (i in which(valid)) {
if (is.na(x$observed_expected[i])) next
# theta_val <- theta_values[i]
# if (is.na(theta_val) || theta_val <= 0) {
#   log_theta_str <- "       NA"
# } else {
#   log_theta_str <- sprintf("%9.5f", log(theta_val))
# }
ci_str <- sprintf("[%5.2f, %5.2f]", x$ci_lower[i], x$ci_upper[i])
cat(sprintf("%5d  %s  %7d    %5.2f   %15s  %5.2f   %5.1f %5.1f %5.1f %5.1f %5.1f   %5.1f%%\n",
x$source_scores[i], log_theta_str, x$observed_rounded[i], x$observed_expected[i],
ci_str, x$see[i],
x$error_freq[i, 1], x$error_freq[i, 2], x$error_freq[i, 3],
x$error_freq[i, 4], x$error_freq[i, 5],
x$prop_failed[i]))
}
cat("--------------------------------------------------------------------------------------------------------\n")
cat(sprintf("Average SEE: %.2f\n", x$avg_see))
}
print(boot_indirect1)
#' Print SEE table for indirect equating
#' @keywords internal
print_indirect_see_table <- function(x) {
conf_pct <- round(x$conf_level * 100)
cat(sprintf("Indirect Equating: %s -> %s (with %d%% CI)\n",
x$indirect_eq$source_name, x$indirect_eq$target_name, conf_pct))
cat("=======================================================================================\n\n")
valid <- x$source_scores >= x$source_min & x$source_scores <= x$source_max
# Get theta values from indirect equating table
#theta_values <- x$indirect_eq$equating_table$theta
cat("                                                                  Frequency of bootstrap errors\n")
cat(sprintf("Score      Rounded  Expected    %d%% CI          SEE      -2    -1     0    +1    +2   Failed%%\n", conf_pct))
cat("--------------------------------------------------------------------------------------------------------\n")
for (i in which(valid)) {
if (is.na(x$observed_expected[i])) next
# theta_val <- theta_values[i]
# if (is.na(theta_val) || theta_val <= 0) {
#   log_theta_str <- "       NA"
# } else {
#   log_theta_str <- sprintf("%9.5f", log(theta_val))
# }
ci_str <- sprintf("[%5.2f, %5.2f]", x$ci_lower[i], x$ci_upper[i])
cat(sprintf("%5d  %s  %7d    %5.2f   %15s  %5.2f   %5.1f %5.1f %5.1f %5.1f %5.1f   %5.1f%%\n",
x$source_scores[i], #log_theta_str,
x$observed_rounded[i], x$observed_expected[i],
ci_str, x$see[i],
x$error_freq[i, 1], x$error_freq[i, 2], x$error_freq[i, 3],
x$error_freq[i, 4], x$error_freq[i, 5],
x$prop_failed[i]))
}
cat("--------------------------------------------------------------------------------------------------------\n")
cat(sprintf("Average SEE: %.2f\n", x$avg_see))
}
print(boot_indirect1)
summary(boot_indirect1)
print(boot_indirect1)
boot_indirect1
#' Get indirect equating table
#'
#' @param boot A leunbach_indirect_bootstrap object
#' @return A data frame with equating results and CIs
#' @export
get_indirect_equating_table <- function(boot) {
if (!inherits(boot, "leunbach_indirect_bootstrap")) {
stop("Input must be a leunbach_indirect_bootstrap object")
}
valid <- boot$source_scores >= boot$source_min &
boot$source_scores <= boot$source_max
# Get theta values from indirect equating table and convert to log
#theta_values <- boot$indirect_eq$equating_table$theta[valid]
log_theta <- ifelse(is.na(theta_values) | theta_values <= 0, NA, round(log(theta_values), 4))
result <- data.frame(
source = boot$source_scores[valid],
#log_theta = log_theta,
rounded = boot$observed_rounded[valid],
expected = round(boot$observed_expected[valid], 2),
ci_lower = round(boot$ci_lower[valid], 2),
ci_upper = round(boot$ci_upper[valid], 2),
see = round(boot$see[valid], 2),
pct_failed = round(boot$prop_failed[valid], 1)
)
colnames(result)[1] <- boot$indirect_eq$source_name
return(result)
}
print(boot_indirect1)
summary(boot_indirect1)
get_indirect_equating_table(boot_indirect1)
#' Get indirect equating table
#'
#' @param boot A leunbach_indirect_bootstrap object
#' @return A data frame with equating results and CIs
#' @export
get_indirect_equating_table <- function(boot) {
if (!inherits(boot, "leunbach_indirect_bootstrap")) {
stop("Input must be a leunbach_indirect_bootstrap object")
}
valid <- boot$source_scores >= boot$source_min &
boot$source_scores <= boot$source_max
# Get theta values from indirect equating table and convert to log
#theta_values <- boot$indirect_eq$equating_table$theta[valid]
#log_theta <- ifelse(is.na(theta_values) | theta_values <= 0, NA, round(log(theta_values), 4))
result <- data.frame(
source = boot$source_scores[valid],
#log_theta = log_theta,
rounded = boot$observed_rounded[valid],
expected = round(boot$observed_expected[valid], 2),
ci_lower = round(boot$ci_lower[valid], 2),
ci_upper = round(boot$ci_upper[valid], 2),
see = round(boot$see[valid], 2),
pct_failed = round(boot$prop_failed[valid], 1)
)
colnames(result)[1] <- boot$indirect_eq$source_name
return(result)
}
get_indirect_equating_table(boot_indirect1)
#' Get indirect equating table
#'
#' @param boot A leunbach_indirect_bootstrap object
#' @return A data frame with equating results and CIs
#' @export
get_indirect_equating_table <- function(boot) {
if (!inherits(boot, "leunbach_indirect_bootstrap")) {
stop("Input must be a leunbach_indirect_bootstrap object")
}
valid <- boot$source_scores >= boot$source_min &
boot$source_scores <= boot$source_max
# Get theta values from indirect equating table and convert to log
#theta_values <- boot$indirect_eq$equating_table$theta[valid]
#log_theta <- ifelse(is.na(theta_values) | theta_values <= 0, NA, round(log(theta_values), 4))
result <- data.frame(
source = boot$source_scores[valid],
#log_theta = log_theta,
expected = round(boot$observed_expected[valid], 2),
ci_lower = round(boot$ci_lower[valid], 2),
ci_upper = round(boot$ci_upper[valid], 2),
rounded = boot$observed_rounded[valid],
see = round(boot$see[valid], 2),
pct_failed = round(boot$prop_failed[valid], 1)
)
colnames(result)[1] <- boot$indirect_eq$source_name
return(result)
}
get_indirect_equating_table(boot_indirect1)
#' Print SEE table for indirect equating
#' @keywords internal
print_indirect_see_table <- function(x) {
conf_pct <- round(x$conf_level * 100)
cat(sprintf("Indirect Equating: %s -> %s (with %d%% CI)\n",
x$indirect_eq$source_name, x$indirect_eq$target_name, conf_pct))
cat("=======================================================================================\n\n")
valid <- x$source_scores >= x$source_min & x$source_scores <= x$source_max
# Get theta values from indirect equating table
#theta_values <- x$indirect_eq$equating_table$theta
cat("                                                                  Frequency of bootstrap errors\n")
cat(sprintf("Score      Rounded  Expected    %d%% CI          SEE      -2    -1     0    +1    +2   Failed%%\n", conf_pct))
cat("--------------------------------------------------------------------------------------------------------\n")
for (i in which(valid)) {
if (is.na(x$observed_expected[i])) next
# theta_val <- theta_values[i]
# if (is.na(theta_val) || theta_val <= 0) {
#   log_theta_str <- "       NA"
# } else {
#   log_theta_str <- sprintf("%9.5f", log(theta_val))
# }
ci_str <- sprintf("[%5.2f, %5.2f]", x$ci_lower[i], x$ci_upper[i])
cat(sprintf("%5d  %s  %7d    %5.2f   %15s  %5.2f   %5.1f %5.1f %5.1f %5.1f %5.1f   %5.1f%%\n",
x$source_scores[i], #log_theta_str,
x$observed_rounded[i], x$observed_expected[i],
ci_str, x$see[i],
x$error_freq[i, 1], x$error_freq[i, 2], x$error_freq[i, 3],
x$error_freq[i, 4], x$error_freq[i, 5],
x$prop_failed[i]))
}
cat("--------------------------------------------------------------------------------------------------------\n")
cat(sprintf("Average SEE: %.2f\n", x$avg_see))
}
print(boot_indirect1)
#' Print SEE table for indirect equating
#' @keywords internal
print_indirect_see_table <- function(x) {
conf_pct <- round(x$conf_level * 100)
cat(sprintf("Indirect Equating: %s -> %s (with %d%% CI)\n",
x$indirect_eq$source_name, x$indirect_eq$target_name, conf_pct))
cat("=======================================================================================\n\n")
valid <- x$source_scores >= x$source_min & x$source_scores <= x$source_max
# Get theta values from indirect equating table
#theta_values <- x$indirect_eq$equating_table$theta
cat("                                                                  Frequency of bootstrap errors\n")
cat(sprintf("Score      Rounded  Expected    %d%% CI          SEE      -2    -1     0    +1    +2   Failed%%\n", conf_pct))
cat("--------------------------------------------------------------------------------------------------------\n")
for (i in which(valid)) {
if (is.na(x$observed_expected[i])) next
# theta_val <- theta_values[i]
# if (is.na(theta_val) || theta_val <= 0) {
#   log_theta_str <- "       NA"
# } else {
#   log_theta_str <- sprintf("%9.5f", log(theta_val))
# }
ci_str <- sprintf("[%5.2f, %5.2f]", x$ci_lower[i], x$ci_upper[i])
cat(sprintf("%5d  %s  %7d    %5.2f   %15s  %5.2f   %5.1f %5.1f %5.1f %5.1f %5.1f   %5.1f%%\n",
#x$source_scores[i], #log_theta_str,
x$observed_rounded[i], x$observed_expected[i],
ci_str, x$see[i],
x$error_freq[i, 1], x$error_freq[i, 2], x$error_freq[i, 3],
x$error_freq[i, 4], x$error_freq[i, 5],
x$prop_failed[i]))
}
cat("--------------------------------------------------------------------------------------------------------\n")
cat(sprintf("Average SEE: %.2f\n", x$avg_see))
}
#' Print SEE table for indirect equating
#' @keywords internal
print_indirect_see_table <- function(x) {
conf_pct <- round(x$conf_level * 100)
cat(sprintf("Indirect Equating: %s -> %s (with %d%% CI)\n",
x$indirect_eq$source_name, x$indirect_eq$target_name, conf_pct))
cat("=======================================================================================\n\n")
valid <- x$source_scores >= x$source_min & x$source_scores <= x$source_max
# Get theta values from indirect equating table
#theta_values <- x$indirect_eq$equating_table$theta
cat("                                                                  Frequency of bootstrap errors\n")
cat(sprintf("Score      Rounded  Expected    %d%% CI          SEE      -2    -1     0    +1    +2   Failed%%\n", conf_pct))
cat("--------------------------------------------------------------------------------------------------------\n")
for (i in which(valid)) {
if (is.na(x$observed_expected[i])) next
# theta_val <- theta_values[i]
# if (is.na(theta_val) || theta_val <= 0) {
#   log_theta_str <- "       NA"
# } else {
#   log_theta_str <- sprintf("%9.5f", log(theta_val))
# }
ci_str <- sprintf("[%5.2f, %5.2f]", x$ci_lower[i], x$ci_upper[i])
cat(sprintf("%5d  %s  %7d    %5.2f   %15s  %5.2f   %5.1f %5.1f %5.1f %5.1f %5.1f   %5.1f%%\n",
x$source_scores[i], #log_theta_str,
x$observed_rounded[i], x$observed_expected[i],
ci_str, x$see[i],
x$error_freq[i, 1], x$error_freq[i, 2], x$error_freq[i, 3],
x$error_freq[i, 4], x$error_freq[i, 5],
x$prop_failed[i]))
}
cat("--------------------------------------------------------------------------------------------------------\n")
cat(sprintf("Average SEE: %.2f\n", x$avg_see))
}
print(boot_indirect1)
View(print_indirect_see_table)
View(print.leunbach_indirect)
print(boot_indirect1)
