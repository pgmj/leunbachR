log_theta_str <- "       NA"
} else {
log_theta_str <- sprintf("%9.4f", log(theta_val))
}
ci_str <- sprintf("[%5.2f, %5.2f]", x$ci_lower[i], x$ci_upper[i])
cat(sprintf("%5d  %s  %7d    %5.2f   %15s  %5.2f   %5.1f %5.1f %5.1f %5.1f %5.1f   %5.1f%%\n",
x$source_scores[i], log_theta_str, x$observed_rounded[i], x$observed_expected[i],
ci_str, x$see[i],
x$error_freq[i, 1], x$error_freq[i, 2], x$error_freq[i, 3],
x$error_freq[i, 4], x$error_freq[i, 5],
x$prop_failed[i]))
}
cat("--------------------------------------------------------------------------------------------------------\n")
cat(sprintf("Average SEE: %.2f\n", x$avg_see))
}
#' Diagnostic function for equating
#'
#' @description
#' Diagnoses potential issues with person parameter estimation by displaying
#' theta values and expected scores for each source score.
#'
#' @param fit A leunbach_ipf object
#' @param direction Direction of equating:  "1to2" or "2to1"
#' @param method Optimization method: "optimize" or "newton"
#'
#' @export
diagnose_equating <- function(fit, direction = c("1to2", "2to1"),
method = c("optimize", "newton")) {
direction <- match.arg(direction)
method <- match.arg(method)
if (direction == "1to2") {
source_scores <- fit$test1_scores
source_gamma <- fit$gamma
source_min <- fit$xmin
source_max <- fit$xmax
target_gamma <- fit$delta
target_min <- fit$ymin
target_max <- fit$ymax
} else {
source_scores <- fit$test2_scores
source_gamma <- fit$delta
source_min <- fit$ymin
source_max <- fit$ymax
target_gamma <- fit$gamma
target_min <- fit$xmin
target_max <- fit$xmax
}
cat("Diagnostic for equating\n")
cat("=======================\n\n")
cat(sprintf("Method: %s\n", method))
cat(sprintf("Source range: %d to %d\n", source_min, source_max))
cat(sprintf("Target range:  %d to %d\n\n", target_min, target_max))
cat("Score  Theta (raw)    Theta (log)    Expected Target\n")
cat("-----------------------------------------------------\n")
for (x in source_scores[source_scores >= source_min & source_scores <= source_max]) {
theta <- estimate_person_parameter(x, source_gamma, source_min, source_max,
method = method)
if (! is.na(theta) && theta > 0) {
true_score <- calculate_true_score(theta, target_gamma, target_min, target_max)
cat(sprintf("%5d  %12.6f  %12.6f  %12.2f\n",
x, theta, log(theta), true_score))
} else {
cat(sprintf("%5d  %12s  %12s  %12s\n", x, "NA", "NA", "NA"))
}
}
}
#' Extract equating table with bootstrap confidence intervals
#'
#' @description
#' Extracts equating results from a bootstrap object as a clean data frame
#' with log theta values, confidence intervals and standard errors.
#'
#' @param boot A leunbach_bootstrap object
#' @param direction "1to2" or "2to1"
#'
#' @return A data frame with equating results and CIs
#' @export
get_equating_table <- function(boot, direction = c("1to2", "2to1")) {
if (!inherits(boot, "leunbach_bootstrap")) {
stop("Input must be a leunbach_bootstrap object")
}
direction <- match.arg(direction)
if (direction == "1to2") {
eq_table <- boot$eq_1to2$equating_table
see <- boot$see_1to2
ci_lower <- boot$ci_lower_1to2
ci_upper <- boot$ci_upper_1to2
source_min <- boot$fit$xmin
source_max <- boot$fit$xmax
scores <- boot$fit$test1_scores
} else {
eq_table <- boot$eq_2to1$equating_table
see <- boot$see_2to1
ci_lower <- boot$ci_lower_2to1
ci_upper <- boot$ci_upper_2to1
source_min <- boot$fit$ymin
source_max <- boot$fit$ymax
scores <- boot$fit$test2_scores
}
valid <- scores >= source_min & scores <= source_max
# Get theta values and convert to log_theta
theta_vals <- eq_table[valid, 2]
log_theta <- ifelse(is.na(theta_vals) | theta_vals <= 0, NA, round(log(theta_vals), 4))
result <- data.frame(
source_score = eq_table[valid, 1],
log_theta = log_theta,
rounded = eq_table[valid, 4],
expected = round(eq_table[valid, 3], 2),
ci_lower = round(ci_lower[valid], 2),
ci_upper = round(ci_upper[valid], 2),
see = round(see[valid], 2)
)
colnames(result)[1] <- colnames(eq_table)[1]
return(result)
}
#' Get indirect equating table
#'
#' @param boot A leunbach_indirect_bootstrap object
#' @return A data frame with equating results and CIs
#' @export
get_indirect_equating_table <- function(boot) {
if (!inherits(boot, "leunbach_indirect_bootstrap")) {
stop("Input must be a leunbach_indirect_bootstrap object")
}
valid <- boot$source_scores >= boot$source_min &
boot$source_scores <= boot$source_max
# Get theta values from indirect equating table and convert to log
theta_values <- boot$indirect_eq$equating_table$theta[valid]
log_theta <- ifelse(is.na(theta_values) | theta_values <= 0, NA, round(log(theta_values), 4))
result <- data.frame(
source = boot$source_scores[valid],
log_theta = log_theta,
rounded = boot$observed_rounded[valid],
expected = round(boot$observed_expected[valid], 2),
ci_lower = round(boot$ci_lower[valid], 2),
ci_upper = round(boot$ci_upper[valid], 2),
see = round(boot$see[valid], 2),
pct_failed = round(boot$prop_failed[valid], 1)
)
colnames(result)[1] <- boot$indirect_eq$source_name
return(result)
}
#' Get indirect equating table
#'
#' @param boot A leunbach_indirect_bootstrap object
#' @return A data frame with equating results and CIs
#' @export
get_indirect_equating_table <- function(boot) {
if (!inherits(boot, "leunbach_indirect_bootstrap")) {
stop("Input must be a leunbach_indirect_bootstrap object")
}
valid <- boot$source_scores >= boot$source_min &
boot$source_scores <= boot$source_max
# Get theta values from indirect equating table and convert to log
theta_values <- boot$indirect_eq$equating_table$theta[valid]
log_theta <- ifelse(is.na(theta_values) | theta_values <= 0, NA, round(log(theta_values), 6))
result <- data.frame(
source = boot$source_scores[valid],
log_theta = log_theta,
rounded = boot$observed_rounded[valid],
expected = round(boot$observed_expected[valid], 2),
ci_lower = round(boot$ci_lower[valid], 2),
ci_upper = round(boot$ci_upper[valid], 2),
see = round(boot$see[valid], 2),
pct_failed = round(boot$prop_failed[valid], 1)
)
colnames(result)[1] <- boot$indirect_eq$source_name
return(result)
}
#' Get indirect equating table
#'
#' @param boot A leunbach_indirect_bootstrap object
#' @return A data frame with equating results and CIs
#' @export
get_indirect_equating_table <- function(boot) {
if (!inherits(boot, "leunbach_indirect_bootstrap")) {
stop("Input must be a leunbach_indirect_bootstrap object")
}
valid <- boot$source_scores >= boot$source_min &
boot$source_scores <= boot$source_max
# Get theta values from indirect equating table and convert to log
theta_values <- boot$indirect_eq$equating_table$theta[valid]
log_theta <- ifelse(is.na(theta_values) | theta_values <= 0, NA, round(log(theta_values), 6))
result <- data.frame(
source = boot$source_scores[valid],
log_theta = log_theta,
rounded = boot$observed_rounded[valid],
expected = round(boot$observed_expected[valid], 2),
ci_lower = round(boot$ci_lower[valid], 2),
ci_upper = round(boot$ci_upper[valid], 2),
see = round(boot$see[valid], 2),
pct_failed = round(boot$prop_failed[valid], 1)
)
colnames(result)[1] <- boot$indirect_eq$source_name
return(result)
}
#' Calculate Goodman-Kruskal Gamma and test statistic
#'
#' @description
#' Computes Goodman & Kruskal's Gamma coefficient for both observed and
#' expected tables, and tests whether they differ significantly.
#' Gamma measures the strength of association between two ordinal variables.
#' Uses a one-sided test following the DIGRAM implementation.
#'
#' @param observed Observed contingency table
#' @param expected Expected (fitted) contingency table
#'
#' @return A list containing:
#'   - gamma_observed: Gamma coefficient for observed data
#'   - gamma_expected: Gamma coefficient for expected data
#'   - se_gamma:  Standard error of gamma
#'   - z_statistic: Z statistic (expected - observed) / SE
#'   - p_value: One-sided p-value from standard normal
#'
#' @keywords internal
calculate_gamma_test <- function(observed, expected) {
# Calculate Gamma for a contingency table
# Gamma = (P - Q) / (P + Q)
# where P = concordant pairs, Q = discordant pairs
calc_gamma <- function(tab) {
n_row <- nrow(tab)
n_col <- ncol(tab)
P <- 0  # Concordant pairs
Q <- 0  # Discordant pairs
for (i in 1:(n_row - 1)) {
for (j in 1:(n_col - 1)) {
n_ij <- tab[i, j]
if (n_ij > 0) {
# Concordant:  cells below and to the right
for (k in (i + 1):n_row) {
for (l in (j + 1):n_col) {
P <- P + n_ij * tab[k, l]
}
}
# Discordant: cells below and to the left
for (k in (i + 1):n_row) {
for (l in 1:(j - 1)) {
if (l >= 1) {
Q <- Q + n_ij * tab[k, l]
}
}
}
}
}
}
if ((P + Q) == 0) {
return(list(gamma = NA, P = P, Q = Q))
}
gamma_val <- (P - Q) / (P + Q)
return(list(gamma = gamma_val, P = P, Q = Q))
}
# Calculate gamma for observed and expected
obs_result <- calc_gamma(observed)
exp_result <- calc_gamma(expected)
gamma_observed <- obs_result$gamma
gamma_expected <- exp_result$gamma
if (is.na(gamma_observed) || is.na(gamma_expected)) {
return(list(
gamma_observed = gamma_observed,
gamma_expected = gamma_expected,
se_gamma = NA,
z_statistic = NA,
p_value = NA
))
}
# Calculate standard error of gamma using ASE1
# ASE1 = (2 / (P + Q)) * sqrt(sum_ij n_ij * (Q * C_ij - P * D_ij)^2)
# where C_ij = sum of cells concordant with (i,j)
#       D_ij = sum of cells discordant with (i,j)
n_row <- nrow(observed)
n_col <- ncol(observed)
P <- obs_result$P
Q <- obs_result$Q
# Pre-compute C_ij and D_ij for each cell
C_matrix <- matrix(0, nrow = n_row, ncol = n_col)
D_matrix <- matrix(0, nrow = n_row, ncol = n_col)
for (i in 1:n_row) {
for (j in 1:n_col) {
# C_ij:  cells that would be concordant with (i,j)
# Cells above-left and below-right
c_sum <- 0
d_sum <- 0
# Above and to the left
if (i > 1 && j > 1) {
for (k in 1:(i - 1)) {
for (l in 1:(j - 1)) {
c_sum <- c_sum + observed[k, l]
}
}
}
# Below and to the right
if (i < n_row && j < n_col) {
for (k in (i + 1):n_row) {
for (l in (j + 1):n_col) {
c_sum <- c_sum + observed[k, l]
}
}
}
# Above and to the right (discordant)
if (i > 1 && j < n_col) {
for (k in 1:(i - 1)) {
for (l in (j + 1):n_col) {
d_sum <- d_sum + observed[k, l]
}
}
}
# Below and to the left (discordant)
if (i < n_row && j > 1) {
for (k in (i + 1):n_row) {
for (l in 1:(j - 1)) {
d_sum <- d_sum + observed[k, l]
}
}
}
C_matrix[i, j] <- c_sum
D_matrix[i, j] <- d_sum
}
}
# ASE1 calculation (variance, not SD yet)
sum_sq <- 0
for (i in 1:n_row) {
for (j in 1:n_col) {
n_ij <- observed[i, j]
if (n_ij > 0) {
term <- Q * C_matrix[i, j] - P * D_matrix[i, j]
sum_sq <- sum_sq + n_ij * term^2
}
}
}
# SE calculation
if ((P + Q) > 0 && sum_sq > 0) {
se_gamma <- (2 / (P + Q)) * sqrt(sum_sq)
} else {
se_gamma <- NA
}
# Z test:  (expected - observed) / SE
# One-sided p-value following DIGRAM
if (! is.na(se_gamma) && se_gamma > 0) {
z_statistic <- (gamma_expected - gamma_observed) / se_gamma
p_value <- pnorm(z_statistic)  # One-sided p-value
} else {
z_statistic <- NA
p_value <- NA
}
list(
gamma_observed = gamma_observed,
gamma_expected = gamma_expected,
se_gamma = se_gamma,
z_statistic = z_statistic,
p_value = p_value
)
}
print(boot)
# import code
files <- list.files(path = "R")
for (i in files) {
source(paste0("R/",i))
}
fit_ab <- leunbach_ipf(d1[,c(1,2)])
fit_bc <- leunbach_ipf(d1[,c(2,3)])
indirect1 <- leunbach_indirect_equate(fit_ab, fit_bc,
direction_ab = "1to2",
direction_bc = "1to2")
print(indirect1)
boot_indirect1 <- leunbach_indirect_bootstrap(fit_ab, fit_bc,
direction_ab = "1to2",
direction_bc = "1to2",
nsim = 100,
verbose = TRUE, n_cores = 4)
print(boot_indirect1)
summary(boot_indirect1)
plot(boot_indirect1, type = "equating")
plot(boot_indirect1, type = "see")
get_equating_table(boot)
?write_csv
write.csv(get_equating_table(boot), file = "eqtable.csv")
#' Print method for leunbach_indirect objects
#' @export
print.leunbach_indirect <- function(x, ...) {
cat("Leunbach Indirect Equating\n")
cat("==========================\n\n")
cat(sprintf("Path: %s -> %s -> %s\n", x$source_name, x$anchor_name, x$target_name))
cat(sprintf("Method: %s\n\n", x$method))
cat(sprintf("Source (%s) range:  %d to %d\n", x$source_name, x$source_min, x$source_max))
cat(sprintf("Anchor (%s) range: %d to %d\n", x$anchor_name, x$anchor_min, x$anchor_max))
cat(sprintf("Target (%s) range: %d to %d\n\n", x$target_name, x$target_min, x$target_max))
tab <- x$equating_table
# Filter to valid range
valid_idx <- tab$source >= x$source_min & tab$source <= x$source_max
tab <- tab[valid_idx, ]
# Format for display
display_tab <- data.frame(
Score = tab$source,
Log_Theta = ifelse(is.na(tab$theta) | tab$theta <= 0,
"      NA",
sprintf("%8.4f", log(tab$theta))),
Expected = sprintf("%6.2f", tab$expected),
Rounded = tab$rounded
)
colnames(display_tab) <- c(x$source_name, "Theta",
paste0("Expected_", x$target_name),
paste0("Rounded_", x$target_name))
print(display_tab, row.names = FALSE)
invisible(x)
}
print(boot_indirect1)
# import code
files <- list.files(path = "R")
for (i in files) {
source(paste0("R/",i))
}
set.seed(87365)
d3a <- data.frame(
a_sum = c(1L,4L,
4L,6L,8L,6L,3L,3L,6L,7L,8L,5L,5L,
6L,6L,6L,8L,4L,8L,5L,4L,2L,0L,3L,
2L,5L,7L,6L,5L,6L,5L,6L,4L,3L,9L,4L,
5L,3L,5L,1L,4L,4L,6L,7L,4L,2L,8L,
5L,7L,3L,4L,8L,4L,5L,4L,8L,3L,5L,
5L,7L,8L,6L,2L,5L,3L,6L,5L,6L,5L,
8L,5L,0L,6L,5L,7L,5L,3L,5L,7L,7L,8L,
5L,3L,7L,4L,3L,8L,4L,5L,6L,6L,7L,
5L,6L,5L,4L,8L,4L,8L,8L,4L,5L,3L,
4L,3L,5L,7L,4L,2L,5L,6L,3L,3L,5L,
6L,9L,5L,3L,3L,3L,9L,2L,7L,2L,6L,3L,
7L,6L,2L,8L,7L,5L,9L,5L,5L,8L,3L,
5L,4L,3L,5L,0L,5L,2L,5L,8L,3L,4L,
6L,4L,5L,3L,2L,5L,6L,5L,6L,1L,5L,
4L,7L,4L,5L,8L,3L,6L,7L,2L,6L,2L,4L,
7L,2L,8L,1L,6L,6L,5L,2L,5L,3L,7L,
4L,6L,4L,5L,10L,8L,6L,6L,8L,8L,6L,
3L,3L,9L,7L,5L,1L,4L,5L,8L,4L,5L,
3L,4L,4L,4L,4L,3L,6L,6L,9L,6L,4L,
6L,4L,5L,2L,2L,1L,5L,6L,3L,5L,6L,6L,
4L,8L,6L,7L,4L,3L,2L,3L,1L,7L,7L,
4L,3L,6L,4L,6L,4L,4L,6L,5L,2L,3L,
5L,6L,3L,3L,3L,4L,9L,8L,6L,4L,1L,
0L,7L,6L,6L,7L,5L,4L,1L,5L,6L,5L,6L,
4L,3L,7L,2L,6L,3L,8L,5L,8L,4L,6L,
2L,7L,3L,4L,7L,4L,3L,5L,7L,6L,9L,
7L,5L,9L,3L,5L,9L,2L,5L,5L,2L,6L,
6L,3L,3L,2L,8L,5L,5L,3L,3L,4L,5L,1L,
4L,7L,7L,3L,7L,5L,6L,6L,6L,7L,6L,
7L,4L,4L,8L,4L,8L,8L,4L,4L,5L,3L,
4L,9L,6L,5L,4L,5L,3L,4L,5L,6L,8L,
6L,2L,3L,3L,3L,4L,7L,8L,3L,10L,6L,
7L,3L,5L,6L,4L,4L,4L,4L,3L,9L,5L,1L,
6L,5L,5L,5L,6L,3L,3L,5L,4L,3L,5L,
6L,6L,7L,4L,6L,3L,2L,1L,6L,5L,9L,
4L,4L,5L,5L,5L,2L,4L,3L,3L,4L,1L,
6L,4L,4L,5L,5L,4L,8L,5L,4L,8L,5L,6L,
2L,5L,7L,3L,4L,6L,6L,8L,6L,7L,3L,
4L,3L,5L,5L,3L,8L,9L,9L,1L,5L,3L,
4L,6L,6L,1L,3L,9L,6L,6L,9L,8L,7L,
7L,3L,3L,5L,6L,2L,5L,9L,6L,4L,5L,2L,
6L,4L,9L,4L,4L,10L,5L,2L,8L,6L,6L,
7L,2L,6L,3L,5L,4L,6L,5L,6L,4L,8L,
6L,5L,4L,7L,8L,9L,2L,2L,4L,6L,3L,
3L,7L),
c_sum = c(8L,4L,
7L,3L,5L,6L,6L,4L,5L,2L,6L,6L,6L,
4L,3L,9L,8L,3L,4L,2L,4L,6L,7L,2L,
4L,4L,5L,8L,1L,7L,5L,4L,5L,5L,8L,5L,
7L,8L,2L,6L,8L,2L,4L,9L,8L,3L,4L,
6L,7L,6L,7L,4L,7L,9L,4L,7L,2L,6L,
5L,4L,4L,7L,5L,2L,4L,3L,7L,4L,8L,
9L,4L,4L,6L,5L,3L,9L,8L,1L,6L,4L,4L,
3L,5L,8L,3L,8L,2L,6L,5L,6L,6L,9L,
5L,2L,6L,6L,4L,7L,1L,1L,2L,7L,5L,
7L,3L,6L,8L,4L,5L,7L,3L,7L,3L,4L,
4L,4L,5L,4L,7L,3L,3L,3L,3L,6L,8L,6L,
8L,4L,4L,5L,7L,5L,3L,3L,1L,5L,5L,
5L,8L,3L,7L,8L,4L,4L,3L,4L,4L,7L,
7L,5L,5L,7L,7L,4L,5L,5L,4L,8L,7L,
4L,5L,3L,2L,9L,2L,6L,7L,5L,7L,9L,5L,
3L,4L,6L,6L,2L,3L,8L,8L,3L,4L,5L,
5L,4L,5L,7L,5L,3L,7L,1L,4L,5L,8L,
3L,4L,7L,6L,4L,4L,2L,9L,6L,6L,4L,
8L,6L,7L,8L,1L,4L,6L,7L,5L,5L,5L,8L,
6L,7L,3L,5L,8L,5L,7L,5L,3L,4L,2L,
5L,7L,2L,7L,7L,5L,3L,5L,3L,4L,5L,
8L,5L,4L,4L,7L,3L,3L,9L,8L,6L,6L,
6L,4L,5L,5L,5L,8L,2L,9L,6L,4L,7L,6L,
5L,3L,6L,9L,6L,7L,3L,4L,6L,7L,7L,
6L,6L,3L,4L,6L,7L,4L,4L,2L,6L,4L,
1L,4L,3L,3L,8L,5L,6L,6L,5L,6L,2L,
7L,5L,8L,6L,6L,7L,2L,4L,2L,6L,3L,5L,
4L,7L,6L,4L,1L,7L,4L,6L,8L,7L,9L,
2L,6L,5L,7L,7L,3L,3L,2L,6L,5L,6L,
6L,5L,6L,2L,4L,7L,3L,1L,1L,7L,9L,
4L,7L,5L,7L,7L,8L,6L,7L,3L,3L,4L,7L,
3L,8L,6L,7L,5L,5L,5L,2L,8L,3L,4L,
9L,7L,5L,2L,6L,4L,5L,8L,7L,3L,9L,
3L,8L,4L,3L,4L,4L,5L,4L,5L,8L,6L,
7L,6L,5L,3L,7L,4L,6L,2L,6L,4L,2L,8L,
4L,8L,2L,8L,6L,3L,7L,5L,4L,6L,2L,
9L,5L,6L,6L,5L,6L,6L,4L,4L,4L,3L,
3L,6L,5L,7L,8L,3L,4L,7L,6L,7L,3L,
5L,6L,4L,4L,5L,4L,2L,3L,5L,5L,6L,8L,
5L,5L,6L,6L,6L,6L,1L,4L,3L,5L,5L,
9L,4L,6L,4L,7L,4L,7L,6L,6L,7L,6L,
7L,8L,7L,8L,9L,6L,3L,4L,4L,5L,5L,
6L,7L,6L,5L,5L,6L,6L,4L,6L,9L,6L,5L,
7L,7L,4L,6L,6L,5L,5L,2L,5L,7L,6L,
3L)
)
fit <- leunbach_ipf(d3a, verbose = TRUE)
print(fit)
leunbach_equate(fit)
boot <- leunbach_bootstrap(fit, verbose = T, n_cores = 12, nsim = 100)
print(boot)
get_equating_table(boot)
